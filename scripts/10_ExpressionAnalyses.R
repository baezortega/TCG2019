# Analysis scripts for Baez-Ortega et al., 2019
# Step 10. Gene expression and mutation burden analyses

# Adrian Baez-Ortega, 2019


# TO RUN THIS SCRIPT IN THE TERMINAL
# ----------------------------------
# Run the commands below in the terminal, replacing '/path/to/TCG2019' with
# the path to the TCG2019 directory.
#
#    cd /path/to/TCG2019
#    Rscript scripts/10_ExpressionAnalyses.R


# TO RUN THIS SCRIPT IN RSTUDIO
# -----------------------------
# Before starting, run the line below in RStudio, replacing '/path/to/TCG2019' with
# the path to the TCG2019 directory.
#
#    setwd("path/to/TCG2019")


# If the paths to the input or output files differ from the ones
# used in this script, they may be updated by modifying the lines below.

INPUT = list(
    
    # Paths to Salmon quantification files
    SALMON = list.files(file.path("data", "original"), pattern="*.sf", full.names=TRUE),
    
    # Path to CanFam3.1 (v90) GTF file from Ensembl
    CF3.GTF = file.path("data", "original", "CanFam3.1.90.chr.gtf"),
    
    # Path to input file containing ID correspondence between coding genes and transcripts
    CF3.TX = file.path("data", "original", "CanFam3.1_Transcripts.tsv"),
    
    # Path to input file of length and burden stats per gene
    GENE.STATS = file.path("data", "original", "Gene_Burden_Stats.RData"),
    
    # Path to input file generated by script 2_ImportVariants.R
    VAR.TABLES = file.path("data", "processed", "Variant_Tables.RData"),
    
    # Path to input file generated by script 3_ProcessAnnotation.R
    VAR.ANNOT = file.path("data", "processed", "Variant_Annotation.RData"),
    
    # Path to input file generated by script 5_PhyloGroups.R
    PHYLO.GROUPS = file.path("data", "processed", "Phylo_Tree_Groups.RData"),
    
    # Path to input file generated by script 7_SignatureAnalyses.R
    SIGNATURES = file.path("data", "processed", "Signatures_Exposures.RData")
    
)

OUTPUT = list(
    
    # Path to output PDF
    PLOTS = file.path("output", "Gene_Expression_Mutation_Burden.pdf"),
    
    # Path to output RData
    RDATA = file.path("data", "processed", "Mean_Transcript_Abundances.RData")
    
)


# Print input and output file paths
cat("\nInput files:\n")
for (name in INPUT) {
    cat(paste0("   ", name), sep="\n")
}
cat("\nOutput files:")
for (name in OUTPUT) {
    cat("\n  ", name)
}
cat("\n\n")


# Function for suppressing terminal output
quiet = function(x) {
    f = file(tempfile(), open="wt")
    sink(f) 
    sink(f, type="message")
    on.exit(sink(type="message"))
    on.exit(sink(), add=TRUE) 
    suppressWarnings(invisible(force(x)))
} 


# Load packages
PACKAGES = c("tximport", "ensembldb", "DESeq2", "stringr", "sigfit")
cat("Loading packages:", paste(PACKAGES, collapse=", "), "\n")
for (package in PACKAGES) {
    quiet(library(package, character.only=T))
}


# Load input data
cat("Loading data...\n")
load(INPUT$VAR.TABLES)
load(INPUT$VAR.ANNOT)
load(INPUT$PHYLO.GROUPS)
load(INPUT$SIGNATURES)
load(INPUT$GENE.STATS)
transcripts = read.table(INPUT$CF3.TX, header=T, stringsAsFactors=F)


## (1) Import transcript abundance data
cat("\nImporting transcript abundance data...\n")

# Associate transcripts with their corresponding gene IDs for gene-level summarization.
# This requires generating an EnsDb (SQLite) file from the CanFam3.1 (v90) GTF file
db = quiet(ensDbFromGtf(gtf=INPUT$CF3.GTF, path=file.path("data", "processed")))
edb = quiet(EnsDb(db))
tx2gene = transcripts(edb, return.type="DataFrame")[, c("tx_id", "gene_id")]

# Import transcript-level abundance estimates
sample.names = gsub(".sf", "", str_split_fixed(INPUT$SALMON, "_", 4)[, 4])
names(INPUT$SALMON) = sample.names

# Convert to gene-level abundance estimates
txi = suppressMessages(tximport(INPUT$SALMON, type="salmon", tx2gene=tx2gene, ignoreTxVersion=T))
stopifnot(all.equal(colnames(txi$counts), sample.names))

# Remove any noncoding genes
abundance.coding = txi$abundance[rownames(txi$abundance) %in% transcripts$Gene &
                                     rownames(txi$abundance) %in% rownames(per.gene.bp), ]

# Obtain mean transcript abundances, and abundance quintiles and deciles
mean.abundances = rowMeans(abundance.coding)
abund.quintiles = quantile(mean.abundances, probs=seq(0, 1, 0.2))
abund.deciles = quantile(mean.abundances, probs=seq(0, 1, 0.1))
abund.quintiles[6] = abund.deciles[11] = Inf

# List genes in each abundance quintile and decile
genes.per.quintile = lapply(1:(length(abund.quintiles)-1), function(i) {
    names(mean.abundances)[mean.abundances >= abund.quintiles[i] & 
                                mean.abundances < abund.quintiles[i+1]]
})
genes.per.decile = lapply(1:(length(abund.deciles)-1), function(i) {
    names(mean.abundances)[mean.abundances >= abund.deciles[i] & 
                                mean.abundances < abund.deciles[i+1]]
})

# Obtain lengths of sequenced genic regions for each quintile and decile
seq.bp.per.quintile = sapply(genes.per.quintile, function(genes) {
    sum(per.gene.bp[genes, "total"])
})
seq.bp.per.decile = sapply(genes.per.decile, function(genes) {
    sum(per.gene.bp[genes, "total"])
})


## (2) Calculate mutation burden per gene expression category
cat("Calculating SNV and indel burdens...\n")

# (a) SNV burden per expression quintile
snv.burden.quintile = t(sapply(c("exon", "intron"), function (region) {
    sapply(genes.per.quintile, function(genes) {
        idx = rownames(per.gene.bp) %in% genes
        len = sum(per.gene.bp[idx, region])
        vars = sum(per.gene.snvs[idx, region])
        vars / len * 1e6
    })
}))

# Std dev and sample size for error bars
snv.burden.quintile.sd = t(sapply(c("exon", "intron"), function (region) {
    sapply(genes.per.quintile, function(genes) {
        idx = which(rownames(per.gene.bp) %in% genes)
        burden = sapply(idx, function(i) {
            per.gene.snvs[i, region] / per.gene.bp[i, region] * 1e6
        })
        sd(burden, na.rm=T)
    })
}))
snv.burden.quintile.n = t(sapply(c("exon", "intron"), function (region) {
    sapply(genes.per.quintile, function(genes) {
        idx = which(rownames(per.gene.bp) %in% genes)
        burden = sapply(idx, function(i) {
            per.gene.snvs[i, region] / per.gene.bp[i, region] * 1e6
        })
        sum(!is.na(burden))
    })
}))

# (b) Indel burden per expression quintile
indel.burden.quintile = lapply(c("insertions", "deletions"), function(mut) {
    t(sapply(c("exon", "intron"), function (region) {
        sapply(genes.per.quintile, function(genes) {
            idx = rownames(per.gene.bp) %in% genes
            len = sum(per.gene.bp[idx, region])
            vars = sum(sapply(per.gene.mut.counts[idx], function(x) x[region, mut]))
            vars / len * 1e6
        })
    }))
})
names(indel.burden.quintile) = c("insertions", "deletions")

# Std dev and sample size for error bars
indel.burden.quintile.sd = lapply(c("insertions", "deletions"), function(mut) {
    t(sapply(c("exon", "intron"), function (region) {
        sapply(genes.per.quintile, function(genes) {
            idx = which(rownames(per.gene.bp) %in% genes)
            burden = sapply(idx, function(i) {
                per.gene.mut.counts[[i]][region, mut] / per.gene.bp[i, region] * 1e6
            })
            sd(burden, na.rm=T)
        })
    }))
})
indel.burden.quintile.n = lapply(c("insertions", "deletions"), function(mut) {
    t(sapply(c("exon", "intron"), function (region) {
        sapply(genes.per.quintile, function(genes) {
            idx = which(rownames(per.gene.bp) %in% genes)
            burden = sapply(idx, function(i) {
                per.gene.mut.counts[[i]][region, mut] / per.gene.bp[i, region] * 1e6
            })
            sum(!is.na(burden))
        })
    }))
})
names(indel.burden.quintile.n) = names(indel.burden.quintile.sd) = names(indel.burden.quintile)


## (3) For each mutation type and category, calculate strand bias per expression decile (in 527T)
cat("Calculating strandwise SNV burden per mutation type...\n")

# Mutation types of interest
mut.types = list(c("ACG>ATG", "CCG>CTG", "GCG>GTG", "TCG>TTG"), "CCC>CTC", "TCC>TTC")

# (a) Make variant category indices
# Predivergence variants
prediv.idx = annot.snvs.tonly$Meta_index %in%
    which(tumour.only.idx)[group.unique.idx[, "Basal trunk (ancestral) [A1]"]]

# Postdivergence variants
postdiv.idx = annot.snvs.tonly$Meta_index %in%
    which(tumour.only.idx)[!group.unique.idx[, "Basal trunk (ancestral) [A1]"]]

# Identify variants present in sample 527T
annot.527T.idx = annot.snvs.tonly$Meta_index %in% which(snvs.nv[, "527T"] >= MIN.READS)

# Make index matrix
annot.categories.527T.idx = cbind("All somatic (527T)" = annot.527T.idx,
                                  "Predivergence, All (527T)" = prediv.idx & annot.527T.idx,
                                  "Postdivergence, All (527T)" = postdiv.idx & annot.527T.idx)

# (b) Obtain strandwise spectra per variant category and expression decile
strand.bias.categ = lapply(1:ncol(annot.categories.527T.idx), function(j) {
    muts = NULL
    # Select mutations in each expression decile
    for (i in 1:length(genes.per.decile)) {
        genes = genes.per.decile[[i]]
        dec.idx = annot.categories.527T.idx[,j] &
            annot.snvs.tonly$Gene %in% genes &
            !grepl("stream", annot.snvs.tonly$Consequence)
        muts = rbind(muts,
                     cbind(i,
                           annot.snvs.tonly$Ref[dec.idx],
                           annot.snvs.tonly$Allele[dec.idx],
                           annot.snvs.tonly$Ref_trinucleotide[dec.idx],
                           annot.snvs.tonly$Strand[dec.idx]))
    }
    # Build strandwise catalogues
    suppressWarnings(sigfit::build_catalogues(muts))
})
names(strand.bias.categ) = colnames(annot.categories.527T.idx)


## (4) Calculate signature exposures per expression quintile
cat("Calculating signature exposures...\n")

# Select variants in each expression quintile
muts = NULL
for (i in 1:length(genes.per.quintile)) {
    genes = genes.per.quintile[[i]]
    quint.idx = annot.snvs.tonly$Gene %in% genes & 
        !grepl("stream", annot.snvs.tonly$Consequence)
    muts = rbind(muts,
                 cbind(i,
                       annot.snvs.tonly$Ref[quint.idx],
                       annot.snvs.tonly$Allele[quint.idx],
                       annot.snvs.tonly$Ref_trinucleotide[quint.idx]))
}

# Fit signatures to variants in each quintile
counts.per.quintile = sigfit::build_catalogues(muts)

quintile.fit = quiet(sigfit::fit_signatures(counts=counts.per.quintile,
                                            signatures=signatures.final[-4, ],
                                            iter=4000, warmup=2000, seed=1756))
exposures.per.quintile = retrieve_pars(quintile.fit, par="exposures")


## (5) Produce mutation burden plots
cat("\nPlotting expression-relative mutation burden plots to output directory...\n")

pdf(OUTPUT$PLOTS, 10, 6)
par(mar=c(4, 6.5, 4, 1))

cols = c("deepskyblue3", "red3")
cols1 = c("#C15E05", "darkorange1")
cols2 = c("dodgerblue4", "dodgerblue3")
lwd = 3.5
main.cex = 1.5
lab.cex = 1.4
leg.cex = 1.4
axis.cex = 1.2
lab.line = 3.5
lab.line2 = 1.8
names.cex = 1e-10
space = c(0,0.7)

# (a) Global SNV burden
max.y = max(snv.burden.quintile + 1.96 * snv.burden.quintile.sd / sqrt(snv.burden.quintile.n)) * 1.05
bars = barplot(snv.burden.quintile, beside=T, col=cols2, border=NA, las=1, ylab="", ylim=c(0, max.y), 
               cex.names=names.cex, cex.axis=axis.cex, cex.main=main.cex, space=space,
               main="Somatic SNV prevalence")
legend("topright", legend=c("Exonic", "Intronic"), 
       fill=cols2, border=NA, bty="n", inset=c(0.03,0), cex=leg.cex)
mtext("Gene expression quintile category", side=1, line=lab.line2, cex=lab.cex)
mtext("Somatic SNV prevalence\n(SNVs per Mb)", side=2, line=lab.line, cex=lab.cex)
ci = lapply(c(1, -1), function(sign) {
    snv.burden.quintile + sign * 1.96 * snv.burden.quintile.sd / sqrt(snv.burden.quintile.n)
})
arrows(bars, ci[[1]], bars, snv.burden.quintile, length=0, col=cols2, lwd=lwd)
box()

# (b) Indel burden
indel.burden.quintile$ins.adj = indel.burden.quintile$insertions + indel.burden.quintile$deletions
max.y = max(indel.burden.quintile$ins.adj + 1.96 * indel.burden.quintile.sd$insertions /
                sqrt(indel.burden.quintile.n$insertions)) * 1.05
bars = barplot(indel.burden.quintile$ins.adj, beside=TRUE, ylim=c(0, max.y), col=cols1, border=NA,
               las=1, ylab="", cex.names=names.cex, cex.axis=axis.cex, space=space)
barplot(indel.burden.quintile$deletions, beside=T, col=cols2, border=NA, axes=FALSE, add=TRUE,
        cex.names=0, cex.main=main.cex, space=space, main="Somatic indel prevalence")
legend("topleft", legend=c("Exonic", "Intronic", "Insertions", "Deletions"), ncol=2, cex=leg.cex,
       fill=c("grey40", "grey70", cols1[2], cols2[2]), border=NA, bty="n", inset=c(0.02,0))
mtext("Gene expression quintile category", side=1, line=lab.line2, cex=lab.cex)
mtext("Somatic indel prevalence\n(indels per Mb)", side=2, line=lab.line, cex=lab.cex)
ins.ci = lapply(c(1, -1), function(sign) {
    indel.burden.quintile$ins.adj + sign * 1.96 * indel.burden.quintile.sd$insertions /
        sqrt(indel.burden.quintile.n$insertions)
})
del.ci = lapply(c(1, -1), function(sign) {
    indel.burden.quintile$deletions + sign * 1.96 * indel.burden.quintile.sd$deletions /
        sqrt(indel.burden.quintile.n$deletions)
})
arrows(bars, ins.ci[[1]], bars, indel.burden.quintile$ins.adj, col=cols1, length=0, lwd=lwd)
arrows(bars, del.ci[[1]], bars, indel.burden.quintile$deletions, col=cols2, length=0, lwd=lwd)
box()

# (c) Signature exposures (mutations/kb)
for (j in c(1,3,4)) {
    exp.mean = exposures.per.quintile$mean[, j] *
        rowSums(counts.per.quintile) / seq.bp.per.quintile * 1e3
    exp.upper = exposures.per.quintile$upper_95[, j] *
        rowSums(counts.per.quintile) / seq.bp.per.quintile * 1e3
    bars = barplot(exp.mean, col="dodgerblue4", border=NA, ylim=c(0, max(exp.upper) * 1.1), 
                   cex.axis=1.2, cex.main=main.cex, las=2, names.arg=FALSE,
                   main=colnames(exposures.per.quintile$mean)[j])
    arrows(bars, exp.mean, bars, exp.upper, 
           angle=90, length=0, lwd=4.5, col="dodgerblue4")
    mtext(text="Gene expression quintile category", side=1, line=lab.line2, cex=lab.cex)
    mtext(text="Signature exposure\n(SNVs per kb)", side=2, line=lab.line, cex=lab.cex)
    box()
}

# (d) Strandwise SNV burden per mutation type
for (mut in mut.types) {
    # Obtain strandwise mutation counts from strand bias and total counts
    counts.strand = lapply(strand.bias.categ, function(sb.cat) {
        rbind(rowSums(sb.cat[, paste0("T:", mut), drop=FALSE]),
              rowSums(sb.cat[, paste0("U:", mut), drop=FALSE]))
    })
    dens.strand = lapply(counts.strand, function(counts) {
        counts / rbind(seq.bp.per.decile, seq.bp.per.decile) * 1e6
    })
    
    for (i in 2:length(dens.strand)) {
        max.y = max(dens.strand[[i]] * 1.1)
        bars = barplot(dens.strand[[i]], beside=T, col=cols, border=NA, las=1, cex.main=main.cex,
                       xaxt="n", yaxt="n", xlab="", ylab="", space=c(0.1, 1), ylim=c(0, max.y),
                       main=paste0(paste(mut, collapse=" / "), "\n", names(dens.strand)[i]))
        lines(colMeans(bars), dens.strand[[i]][1,], col="deepskyblue4", lwd=4, lty=2)
        lines(colMeans(bars), dens.strand[[i]][2,], col="red4", lwd=4, lty=2)
        axis(side=2, las=1, cex.axis=axis.cex)
        mtext(text="Somatic SNV prevalence\n(SNVs per Mb)", side=2, line=lab.line, cex=lab.cex)
        mtext(text="Gene expression decile category", side=1, line=lab.line2, cex=lab.cex)
        legend("topright", fill=cols, border=NA, legend=c("Transcribed", "Untranscribed"), 
               bty="n", inset=c(0.05,0.05), cex=leg.cex)
        box()
    }
}
invisible(dev.off())


# Save mean abundances and genes per abundance quintile and decile
cat("Saving generated objects to file ", OUTPUT$RDATA, "...\n", sep="")
save(mean.abundances, abund.quintiles, abund.deciles, genes.per.quintile, genes.per.decile,
     file=OUTPUT$RDATA)

cat("\nDone\n\n")
