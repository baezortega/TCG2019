# Analysis scripts for Baez-Ortega et al., 2019
# Step 2. Import and classify variants

# Adrian Baez-Ortega, 2018


# TO RUN THIS SCRIPT IN THE TERMINAL
# ----------------------------------
# Run the commands below in the terminal, replacing '/path/to/TCG2019' with the 
# path to the TCG2019 directory.
#
#    cd /path/to/TCG2019
#    Rscript scripts/2_ImportVariants.R


# TO RUN THIS SCRIPT IN RSTUDIO
# -----------------------------
# Before starting, run the line below in RStudio, replacing '/path/to/TCG2019' with 
# the path to the TCG2019 directory.
#
#    setwd("path/to/TCG2019")


# If the paths to the input or output files differ from the ones 
# used in this script, they may be updated by modifying the lines below.

INPUT = list(
    
    # Common portion of the path to the input files generated by the script 1_ExtractVcfData.py
    # (i.e. the path and shared file name before the "_Metadata/NR/NV.txt" suffix)
    SNVS.PREFIX = file.path("data", "processed", "Somatypus_CTVT_SNVs_1052"),
    INDEL.PREFIX = file.path("data", "processed", "Somatypus_CTVT_Indels_1052"),
    DNVS.PREFIX = file.path("data", "processed", "Somatypus_CTVT_DNVs_1051")
    
)

OUTPUT = list(
    
    # Path to output RData file
    RDATA = file.path("data", "processed", "Variant_Tables.RData")
    
)


# Print input and output file paths
SUFFIX = list(Meta="_Metadata.tsv", NR="_NR.tsv", NV="_NV.tsv")

cat("\nInput files:")
for (name in INPUT) {
    for (suffix in SUFFIX) {
        cat("\n   ", name, suffix,
            sep="")
    }
}
cat("\n\nOutput files:")
for (name in OUTPUT) {
    cat("\n  ", name)
}
cat("\n\n")


# Load packages
PACKAGES = c("stringr")
cat("Loading packages:", paste(PACKAGES, collapse=", "), "\n")
for (package in PACKAGES) {
    suppressWarnings(library(package, character.only=TRUE))
}


# Load data
cat("Importing variant data...\n")

snvs.metadata = read.table(paste0(INPUT$SNVS.PREFIX, SUFFIX$Meta), header=T, stringsAsFactors=F)
snvs.nr = read.table(paste0(INPUT$SNVS.PREFIX, SUFFIX$NR), header=T, check.names=F)
snvs.nv = read.table(paste0(INPUT$SNVS.PREFIX, SUFFIX$NV), header=T, check.names=F)

indels.metadata = read.table(paste0(INPUT$INDEL.PREFIX, SUFFIX$Meta), header=T, stringsAsFactors=F)
indels.nr = read.table(paste0(INPUT$INDEL.PREFIX, SUFFIX$NR), header=T, check.names=F)
indels.nv = read.table(paste0(INPUT$INDEL.PREFIX, SUFFIX$NV), header=T, check.names=F)

dnvs.metadata = read.table(paste0(INPUT$DNVS.PREFIX, SUFFIX$Meta), header=T, stringsAsFactors=F)
dnvs.nr = read.table(paste0(INPUT$DNVS.PREFIX, SUFFIX$NR), header=T, check.names=F)
dnvs.nv = read.table(paste0(INPUT$DNVS.PREFIX, SUFFIX$NV), header=T, check.names=F)

# Correct columns in DNV tables to match SNV/indel tables
dnvs.nr$`0708H-Dog` = dnvs.nv$`0708H-Dog` = NA
idx = match("1796H-Dog", colnames(dnvs.nr))
colnames(dnvs.nr)[idx] = colnames(dnvs.nv)[idx] = "0532H2-Dog"
idx = match(colnames(snvs.nr), colnames(dnvs.nr))
dnvs.nr = dnvs.nr[, idx]
dnvs.nv = dnvs.nv[, idx]

if (!all.equal(colnames(snvs.nr), colnames(snvs.nv)) |
    !all.equal(colnames(snvs.nr), colnames(indels.nr)) |
    !all.equal(colnames(snvs.nr), colnames(indels.nv)) |
    !all.equal(colnames(snvs.nr), colnames(dnvs.nr)) |
    !all.equal(colnames(snvs.nr), colnames(dnvs.nv))) {
    stop("Sample names differ between some of the input NR and NV files. Please check column names.")
}

# Remove leading zeroes and "-Dog" suffix from sample names
colnames(snvs.nr) = colnames(snvs.nv) = 
    colnames(indels.nr) = colnames(indels.nv) = 
    colnames(dnvs.nr) = colnames(dnvs.nv) = 
    gsub("(^0)|(^00)|(-Dog)", "", colnames(snvs.nr))

cat("Imported", nrow(snvs.metadata), "SNVs,", nrow(indels.metadata), "indels and",
    nrow(dnvs.metadata), "DNVs.\n\n")


# Sample to exclude from the outset: 708H 
# (This sample has very low quality and it is impossible to determine if it is tumour-contaminated)
LOW.QUAL = c("708H")
cat("Excluding low-quality sample(s):", paste(LOW.QUAL, collapse=", "), "\n\n")

idx = colnames(snvs.nr) %in% LOW.QUAL
snvs.nr = snvs.nr[, !idx]
snvs.nv = snvs.nv[, !idx]
indels.nr = indels.nr[, !idx]
indels.nv = indels.nv[, !idx]
dnvs.nr = dnvs.nr[, !idx]
dnvs.nv = dnvs.nv[, !idx]


# Fix mislabelled samples
relabel = c("532H2" = "1796H",
            "1718H" = "1718H1",
            "1719H" = "1719H1",
            "1720H" = "1719H2",
            "1721H" = "1718H2",
            "1722H" = "1719H3",
            "1723H" = "1719H4",
            "1724H" = "1718H3",
            "1725H" = "1718H4",
            "1726H" = "1719H5",
            "1727H" = "1718H5",
            "1728H" = "1718H6",
            "1729H" = "1719H6")

cat("Relabelling mislabelled samples:\n")
for (i in 1:length(relabel)) {
    cat("  ", names(relabel)[i], " relabelled to ", relabel[i], "\n", sep="")
}

# Include 1771H in order to get correct reordering
relabel = c(relabel, "1771H" = "1771H")

# Relabel columns
idx = match(names(relabel), colnames(snvs.nr))
colnames(snvs.nr)[idx] = colnames(snvs.nv)[idx] = 
    colnames(indels.nr)[idx] = colnames(indels.nv)[idx] =
    colnames(dnvs.nr)[idx] = colnames(dnvs.nv)[idx] = 
    relabel

# Reorder columns by new labels
relabel.order = order(relabel)
reorder.idx = c((1:ncol(snvs.nr))[-idx], idx[relabel.order])
snvs.nr = snvs.nr[, reorder.idx]
snvs.nv = snvs.nv[, reorder.idx]
indels.nr = indels.nr[, reorder.idx]
indels.nv = indels.nv[, reorder.idx]
dnvs.nr = dnvs.nr[, reorder.idx]
dnvs.nv = dnvs.nv[, reorder.idx]


# Retrieve sample names and build host and tumour sample indices
samples = colnames(snvs.nr)
tumours = grepl(".*T.*", samples)
hosts = !tumours
cat("\nFound", sum(tumours), "tumour samples and", sum(hosts), "host samples.\n\n")


# Check duplicates
cat("Removed", sum(duplicated(snvs.metadata[, c("CHROM", "POS", "ALT")])), "duplicated SNVs,", 
    sum(duplicated(indels.metadata[, c("CHROM", "POS")])), "duplicated indels and", 
    sum(duplicated(dnvs.metadata[, c("CHROM", "POS", "ALT")])), "duplicated DNVs.\n\n")

# Remove duplicated DNVs
idx = duplicated(dnvs.metadata[, c("CHROM", "POS", "ALT")])
dnvs.metadata = dnvs.metadata[!idx, ]
dnvs.nr = dnvs.nr[!idx, ]
dnvs.nv = dnvs.nv[!idx, ]


# Compute VAFs
snvs.vaf = snvs.nv / snvs.nr
snvs.vaf[is.na(snvs.vaf)] = 0

indels.vaf = indels.nv / indels.nr
indels.vaf[is.na(indels.vaf)] = 0

dnvs.vaf = dnvs.nv / dnvs.nr
dnvs.vaf[is.na(dnvs.vaf)] = 0


# Identify variants present only in tumours (somatic or 'tumour-only')
# Tumour-only variants are variants that are
#   Found with at least 3 reads in at least one tumour.
#   Not found in the set of variants with VAF >0.25 in hosts. 
MIN.READS = 3
MIN.VAF.H = 0.25

# Unmatched tumour samples lacking a matched host sample are not considered
# in the identification of tumour-only variants, as contaminating germline
# variants from the host dogs cannot be identified in these samples.
tumour.num = str_split_fixed(samples[tumours], "T", 2)[,1]
host.num = str_split_fixed(samples[hosts], "H", 2)[,1]
excluded = rep(FALSE, length(samples))
excluded[tumours][!(tumour.num %in% host.num)] = TRUE
tumours.except.excluded = tumours & !excluded

cat(sum(excluded), "unmatched tumour samples will be excluded from tumour-only variant identification:\n")
cat(samples[excluded], sep=", ")

# Define indices for tumour-only SNVs and indels
# (variants with VAF <0.25 in all hosts and ≥3 reads in ≥1 tumour)
# SNVs
tumour.only.idx = rowSums(snvs.vaf[, hosts] >= MIN.VAF.H) == 0 &
    rowSums(snvs.nv[, tumours.except.excluded] >= MIN.READS) > 0
# Indels
tumour.only.indels.idx = rowSums(indels.vaf[, hosts] >= MIN.VAF.H) == 0 &
    rowSums(indels.nv[, tumours.except.excluded] >= MIN.READS) > 0
# DNVs
tumour.only.dnvs.idx = rowSums(dnvs.vaf[, hosts] >= MIN.VAF.H) == 0 &
    rowSums(dnvs.nv[, tumours.except.excluded] >= MIN.READS) > 0

cat("\n\nFound", sum(tumour.only.idx), "tumour-only (somatic) SNVs,", 
    sum(tumour.only.indels.idx), "tumour-only indels and",
    sum(tumour.only.dnvs.idx), "tumour-only DNVs.\n")


# Identify somatic SNVs/indels present in just one tumour ('tumour-unique')
presence.snvs = snvs.nv[tumour.only.idx, tumours] >= MIN.READS
tumour.unique.idx = matrix(FALSE, nrow=nrow(presence.snvs), ncol=ncol(presence.snvs), 
                           dimnames=dimnames(presence.snvs))
tumour.unique.idx[rowSums(presence.snvs) == 1, ] = 
    presence.snvs[rowSums(presence.snvs) == 1, ]
tumour.unique.any.idx = as.logical(rowSums(tumour.unique.idx))

presence.indels = indels.nv[tumour.only.indels.idx, tumours] >= MIN.READS
tumour.unique.indels.idx = matrix(FALSE, nrow=nrow(presence.indels), ncol=ncol(presence.indels), 
                                  dimnames=dimnames(presence.indels))
tumour.unique.indels.idx[rowSums(presence.indels) == 1, ] = 
    presence.indels[rowSums(presence.indels) == 1, ]

cat("Found", sum(tumour.unique.idx), "tumour-unique SNVs and", 
    sum(tumour.unique.indels.idx), "tumour-unique indels.\n\n")


# Save objects
cat("Saving generated objects to file ", OUTPUT$RDATA, "...\n", sep="")
save(snvs.metadata, snvs.nr, snvs.nv, snvs.vaf, indels.metadata, indels.nr, indels.nv, indels.vaf,
     dnvs.metadata, dnvs.nr, dnvs.nv, dnvs.vaf, samples, tumours, hosts, tumour.only.idx, 
     tumour.only.indels.idx, tumour.only.dnvs.idx, tumour.unique.idx, tumour.unique.any.idx, 
     tumour.unique.indels.idx, excluded, MIN.READS,
     file=OUTPUT$RDATA)

cat("\nDone\n\n")

