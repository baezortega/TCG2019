# Analysis scripts for Baez-Ortega et al., 2019
# Step 8. Mutational spectrum analysis of dinucleotide substitutions

# Adrian Baez-Ortega, 2019


# TO RUN THIS SCRIPT IN THE TERMINAL
# ----------------------------------
# Run the commands below in the terminal, replacing '/path/to/TCG2019' with
# the path to the TCG2019 directory.
#
#    cd /path/to/TCG2019
#    Rscript scripts/8_DinucAnalyses.R


# TO RUN THIS SCRIPT IN RSTUDIO
# -----------------------------
# Before starting, run the line below in RStudio, replacing '/path/to/TCG2019' with
# the path to the TCG2019 directory.
#
#    setwd("path/to/TCG2019")


# If the paths to the input or output files differ from the ones
# used in this script, they may be updated by modifying the lines below.

INPUT = list(
    
    # Path to input file generated by script 2_ImportVariants.R
    VAR.TABLES = file.path("data", "processed", "Variant_Tables.RData"),
    
    # Path to input file generated by script 3_ProcessAnnotation.R
    VAR.ANNOT = file.path("data", "processed", "Variant_Annotation.RData"),
    
    # Path to input file generated by script 5_PhyloGroups.R
    PHYLO.GROUPS = file.path("data", "processed", "Phylo_Tree_Groups.RData")
    
)

OUTPUT = list(
    
    # Path to output spectrum PDF
    SPECTRUM = file.path("output", "Dinucleotide_Spectrum.pdf"),
    
    # Path to output RData file
    RDATA = file.path("data", "processed", "Dinucleotides.RData")
    
)


# Print input and output file paths
cat("\nInput files:")
for (name in INPUT) {
    cat("\n  ", name)
}
cat("\n\nOutput files:")
for (name in OUTPUT) {
    cat("\n  ", name)
}
cat("\n\n")


# Load packages
library(stringr)


# Subfunction: reverse complement
rev.comp = function(nucleotides) {
    as.character(
        rev(sapply(nucleotides, function(nuc) {
            if (nuc == "A") "T"
            else if (nuc == "C") "G"
            else if (nuc == "G") "C"
            else if (nuc == "T") "A"
        })))
}


# Load input data
cat("Loading data...\n")
load(INPUT$VAR.TABLES)
load(INPUT$VAR.ANNOT)
load(INPUT$PHYLO.GROUPS)


cat("Generating mutational spectrum of tumour-only dinucleotide variants...\n")

# Isolate base changes
dnvs.tonly = dnvs.metadata[tumour.only.dnvs.idx, ]
dnv.changes = t(sapply(1:nrow(dnvs.tonly), function(i) {
    c(str_split_fixed(dnvs.tonly[i, "REF"], "", 2), str_split_fixed(dnvs.tonly[i, "ALT"], "", 2), NA)
}))
colnames(dnv.changes) = c("REF1", "REF2", "ALT1", "ALT2", "STRAND")


# Get variant strand from annotation
# (collapsing available annotation for both bases)
annot.snvs.tonly = annot.snvs.tonly[!grepl(".*(upstream|downstream).*", annot.snvs.tonly$Consequence),]
dinuc.str1 = sapply(1:nrow(dnvs.tonly), function(i) {
    paste0(dnvs.tonly[i,"CHROM"], ":", dnvs.tonly[i,"POS"], dnv.changes[i,"ALT1"])
})
dinuc.str2 = sapply(1:nrow(dnvs.tonly), function(i) {
    paste0(dnvs.tonly[i,"CHROM"], ":", dnvs.tonly[i,"POS"] + 1, dnv.changes[i,"ALT2"])
})
annot.str = apply(annot.snvs.tonly[,c("Chrom","Pos","Allele")], 1, function(ann) {
    paste0(ann[1], ":", as.numeric(ann[2]), ann[3])
})
annot.idx1 = match(dinuc.str1, annot.str)
annot.idx2 = match(dinuc.str2, annot.str)
annot.idx1[is.na(annot.idx1)] = annot.idx2[is.na(annot.idx1)]
dnv.changes[, "STRAND"] = annot.snvs.tonly$Strand[annot.idx1]
dnv.metaidx = annot.snvs.tonly$Meta_index[annot.idx1]


# Collapse dinucleotide mutations into nonredundant classes
# Of the 16 dinucleotides, 12 reverse-complement with their alternative dinucleotides
# on the complementary strand: AA, AC, AG, CA, CC, CT, GA, GG, GT, TC, TG, TT. This
# results in 6 collapsed dinucleotides, namely AA/TT, AC/GT, AG/CT, CA/TG, CC/GG, GA/TC.
# Once collapsed, they imply 6x9=54 unique combinations (i.e. 6 dinucleotides, each with
# 9 mutation possibilities).
# However, the remaining 4 dinucleotides (AT, TA, CG, GC) do not change when
# reverse-complemented. Thus, for these dinucleotides there are only 6 mutation possibilities,
# as 3 of the mutation possibilities are identical if reverse-complemented, (e.g. TA>AT
# reverse-complements to TA>AT). This results in an additional 4x6=24 unique combinations.
# Hence, the total number of unique combinations after reverse-complementing (collapsing) is
# 54+24=78.

# Categories not to be reversed complemented: AA>NN, AC>NN, AG>NN, CA>NN, CC>NN, GA>NN
omit = c("AA", "AC", "AG", "CA", "CC", "GA")

dnv.changes.collapsed = t(apply(dnv.changes, 1, function(mut) {
    ref = paste(mut[1:2], collapse="")
    
    # If reference dinuc is not in the 'omit' list
    if (!(ref %in% omit)) {
        
        # If dinuc is not identical to its reverse complement
        if (!all(rev.comp(mut[1:2]) == mut[1:2])) {
            c(rev.comp(mut[1:2]), rev.comp(mut[3:4]), as.character(-1 * as.integer(mut[5])))
        }
        
        # If dinuc is identical to its reverse complement
        else {
            alt = paste(mut[3:4], collapse="")
            
            # If alternate dinuc is not in the 'omit' list and is not equal to its rev comp
            if ((!(alt %in% omit)) & (!all(rev.comp(mut[3:4]) == mut[3:4]))) {
                c(mut[1:2], rev.comp(mut[3:4]), as.character(-1 * as.integer(mut[5])))
            }
            else {
                mut
            }
        }
    }
    
    # If reference dinuc is in the 'omit' list
    else {
        mut
    }
}))


# Create mutation categories
bases = c("A", "C", "G", "T")
coll.dinuc = c("AA", "AC", "AG", "AT", "CA", "CC", "CG", "GA", "GC", "TA")
change.types = NULL
for (ref in coll.dinuc) {
    refs = as.character(str_split_fixed(ref, "", 2))
    for (alt1 in bases) {
        if (alt1 != refs[1]) {
            for (alt2 in bases) {
                if (alt2 != refs[2]) {
                    if (!all(rev.comp(refs) == refs) | 
                        (paste0(alt1, alt2) %in% coll.dinuc)) {
                        change.types = c(change.types, paste0(ref, ">", alt1, alt2))
                    }
                }
            }
        }
    }
}


# Obtain mutation counts for each strand
transcribed = (dnv.changes.collapsed[, 5] == "-1") %in% TRUE
untranscribed = (dnv.changes.collapsed[, 5] == "1") %in% TRUE
dnvs.collapsed = apply(dnv.changes.collapsed, 1, function(mut) {
    paste0(mut[1], mut[2], ">", mut[3], mut[4])
})

counts.untrans = sapply(change.types, function(x) { 
    length(grep(x, dnvs.collapsed[untranscribed]))
})
counts.trans = sapply(change.types, function(x) { 
    length(grep(x, dnvs.collapsed[transcribed]))
})
dnv.spectrum = rbind("Transcribed"=counts.trans, "Untranscribed"=counts.untrans)


# Plot spectrum
cat("Plotting dinucleotide mutational spectrum to output directory...\n")
pdf(OUTPUT$SPECTRUM, width=15, height=7)
par(mar=c(5.25, 5.75, 1, 0))

strand.colours = c("dodgerblue3", "red3")
barplot(dnv.spectrum, beside=T,
        col=strand.colours, border=NA, 
        ylim=c(0, max(dnv.spectrum) * 1.1), xlim=c(0, 190), space=c(0.1, 0.3),
        las=2, yaxt="n", xaxs="i", family="mono", cex.names=1.2)
axis(side=2, las=2, cex.axis=1.25)
mtext(side=2, "Mutations", line=3.5, cex=1.4)
title(paste(sum(dnv.spectrum), "somatic dinucleotide mutations"), cex.main=1.5, line=-1)
legend("topleft", legend=c("Transcribed strand", "Untranscribed strand"), 
       fill=strand.colours, border=strand.colours, bty="n", cex=1.3, inset=c(0.01, 0.06))

invisible(dev.off())


# Obtain number of group-unique CC>TT mutations per group
cat("Obtaining unique CC>TT mutation counts per group...\n")
group.unique.cctt = apply(group.unique.idx, 2, function(group.idx) {
    group.ext.idx = rep(FALSE, nrow(snvs.metadata))
    group.ext.idx[tumour.only.idx][group.idx] = TRUE
    group.dnv.idx = (group.ext.idx[dnv.metaidx]) %in% TRUE
    sum(dnvs.collapsed[group.dnv.idx] == "CC>TT")
})


cat("\nSaving generated objects to file ", OUTPUT$RDATA, "...\n", sep="")
save(dnvs.collapsed, dnv.spectrum, dnv.metaidx, group.unique.cctt,
     file=OUTPUT$RDATA)

cat("\nDone\n\n")

