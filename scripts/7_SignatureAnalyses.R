# Analysis scripts for Baez-Ortega et al., 2019
# Step 7. Mutational signature analyses

# Adrian Baez-Ortega, 2018


# TO RUN THIS SCRIPT IN THE TERMINAL
# ----------------------------------
# Run the commands below in the terminal, replacing '/path/to/TCG2019' with
# the path to the TCG2019 directory.
#
#    cd /path/to/TCG2019
#    Rscript scripts/7_SignatureAnalyses.R


# TO RUN THIS SCRIPT IN RSTUDIO
# -----------------------------
# Before starting, run the line below in RStudio, replacing '/path/to/TCG2019' with
# the path to the TCG2019 directory.
#
#    setwd("path/to/TCG2019")


# If the paths to the input or output files differ from the ones
# used in this script, they may be updated by modifying the lines below.

INPUT = list(
    
    # Path to input file generated by script 2_ImportVariants.R
    VAR.TABLES = file.path("data", "processed", "Variant_Tables.RData"),
    
    # Path to input file generated by script 3_ProcessAnnotation.R
    VAR.ANNOT = file.path("data", "processed", "Variant_Annotation.RData"),
    
    # Path to input file generated by script 5_PhyloGroups.R
    PHYLO.GROUPS = file.path("data", "processed", "Phylo_Tree_Groups.RData")
    
)

OUTPUT = list(
    
    # Path to output directory for plots
    PLOTS.DIR = file.path("output", "Mutational_Signatures_Plots"),
    
    # Path to output signatures table
    SIGNATURES = file.path("output", "Mutational_Signatures_Table.tsv"),
    
    # Path to output pentanucleotide spectrum plots
    PENTA.SPEC = file.path("output", "Mutational_Signatures_Plots", "Pentanucleotide_Spectra.pdf"),
    
    # Path to output RData file
    RDATA = file.path("data", "processed", "Signatures_Exposures.RData")
    
)


# Print input and output file paths
cat("\nInput files:")
for (name in INPUT) {
    cat("\n  ", name)
}
cat("\n\nOutput files:")
for (name in OUTPUT) {
    cat("\n  ", name)
}
cat("\n\n")


# Load packages
PACKAGES = c("sigfit", "stringr")
cat("Loading packages:", paste(PACKAGES, collapse=", "), "\n")
for (package in PACKAGES) {
    suppressWarnings(library(package, character.only=TRUE, quietly=TRUE))
}


# Load input data
cat("Loading data...\n")
load(INPUT$VAR.TABLES)
load(INPUT$VAR.ANNOT)
load(INPUT$PHYLO.GROUPS)


## (1) Generate mutational spectrum of each phylogenetic group
cat("\nGenerating mutational spectra of phylogenetic groups...\n")

# Build table containing group ID, ref base, alt base, and
# trinucleotide context for all group-unique variants
trinuc = substr(str_split_fixed(snvs.metadata$INFO, ";", 20)[, 12], 13, 15)
var.table = matrix(NA, nrow=sum(group.unique.idx), ncol=4,
                   dimnames=list(NULL, c("ID", "REF", "ALT", "CONTEXT")))
i = 1
for (j in 1:ncol(group.unique.idx)) {
    k = i + sum(group.unique.idx[, j]) - 1
    var.table[i:k, ] = cbind(colnames(group.unique.idx)[j],
                             snvs.metadata$REF[tumour.only.idx][group.unique.idx[, j]],
                             snvs.metadata$ALT[tumour.only.idx][group.unique.idx[, j]],
                             trinuc[tumour.only.idx][group.unique.idx[, j]])
    i = k + 1
}

# Build spectra (sigfit)
group.spectra = sigfit::build_catalogues(var.table)


## NB. The commented block of code below performs preliminary extraction of
## 2-5 signatures from the set of all spectra with >700 mutations, and 
## plots the results for N=3 signatures. As these results were found to be
## suboptimal for some groups (notably A1), this step is omitted by default.

# # Extract mutational signatures from all groups with >700 mutations
# # (i.e. all groups except 26, 39, 47, 55)
# MIN.MUT = 700
# MAX.MUT = 2000
# exclude.idx = rowSums(group.spectra) < MIN.MUT
# counts = group.spectra[!exclude.idx, ]
# # Downsample to a maximum of 2000 mutations
# for (i in which(rowSums(counts) > MAX.MUT)) {
#     counts[i, ] = round(counts[i, ] / sum(counts[i, ]) * MAX.MUT)
# }
# # Extract 2-5 signatures
# N = 2:5
# cat("\nPreliminary sigfit run: extracting ", N[1], "-", tail(N, 1),
#     " signatures from all groups with >", MIN.MUT, " mutations\n", sep="")
# cat("Excluded groups:", paste(which(exclude.idx), collapse=", "), "\n\n")
# sigfit.prelim = sigfit::extract_signatures(counts, nsignatures=N,
#                                            iter=1000, seed=1756)
# cat("\nPlotting preliminary (suboptimal) results for extraction of N=3 signatures to output directory...\n")
# invisible(sigfit::plot_all(sigfit.prelim[[3]],
#                            out_path=file.path("output", "Preliminary_Signature_Extraction")))


## (2) Extract N=3 signatures from non-ancestral groups with >700 mutations
# (i.e. all groups except 26, 39, 47, 55, A1, A2, A3), downsampling to
# a maximum of 2000 mutations
# (The extracted signatures correspond to COSMIC signatures 1, 5 and 7)
MIN.MUT = 700
MAX.MUT = 2000
exclude.idx = (rowSums(group.spectra) < MIN.MUT) | (group.ids %in% c("A1", "A2", "A3"))
counts = group.spectra[!exclude.idx, ]
for (i in which(rowSums(counts) > MAX.MUT)) {
    counts[i, ] = round(counts[i, ] / sum(counts[i, ]) * MAX.MUT)
}

# Extract 3 signatures
N = 3
cat("\nExtracting ", N, " signatures from non-ancestral groups with >",
    MIN.MUT, " mutations\n", sep="")
cat("Excluded groups:", paste(group.ids[exclude.idx], collapse=", "), "\n\n")

sigfit.extract.3 = sigfit::extract_signatures(counts, nsignatures=N,
                                              iter=10000, warmup=3000, seed=1756,
                                              control=list(adapt_delta=0.85))

# Retrieve and reorder extracted signatures
# For sigfit v2.x:
signatures.1.5.7 = sigfit::retrieve_pars(sigfit.extract.3, "signatures")$mean[c(2, 1, 3), ]

# For sigfit v1.x:
# signatures.1.5.7 = sigfit::retrieve_pars(sigfit.extract.3, "signatures")$mean[3:1, ]


## (3) Extract the signatures accounting for the additional patterns in groups
# 57, 58, A1, A3, by using sigfit to simultaneously fit the present three
# signatures and extract two additional ones
# Use only groups 57, 58, A1, A3, downsampling to a maximum of 5000 mutations
# (The extracted signatures correspond to signatures A and 2* in the paper)
MAX.MUT = 5000
select.idx = match(c("57", "58", "A1", "A3"), group.ids)
counts = group.spectra[select.idx, ]
for (i in which(rowSums(counts) > MAX.MUT)) {
    counts[i, ] = round(counts[i, ] / sum(counts[i, ]) * MAX.MUT)
}

# Fit 3 signatures, extract 2 signatures
N = 2
cat("\nExtracting", N, "additional signatures from groups:",
    paste(group.ids[select.idx], collapse=", "), "\n\n")

# (Using Jeffreys prior on signatures and exposures)
# For sigfit v2.x:
sigfit.fitext.2 = sigfit::fit_extract_signatures(counts, signatures=signatures.1.5.7,
                                                 num_extra_sigs=N,
                                                 exp_prior=matrix(0.5, nrow=nrow(counts), N+3),
                                                 sig_prior=matrix(0.5, nrow=N, ncol=96),
                                                 iter=10000, warmup=3000, seed=1756)
# For sigfit v1.x:
# sigfit.fitext.2 = sigfit::fit_extract_signatures(counts, signatures=signatures.1.5.7,
#                                                  num_extra_sigs=N, exp_prior=0.5,
#                                                  sig_prior=matrix(0.5, nrow=N, ncol=96),
#                                                  iter=10000, warmup=3000, seed=1756)

# Retrieve and rename extracted signatures
signatures.final = sigfit::retrieve_pars(sigfit.fitext.2, "signatures")$mean
rownames(signatures.final) = paste("Signature", c("1", "5", "7", "2*", "A"))


## NB. The commented block of code below performs preliminary re-fitting of all
## extracted signatures to all phylogenetic groups to obtain preliminary signature
## exposures, and plots the results. Since these results show that signatures 2*
## and A are inactive in most groups, this step is omitted by default.

# # Fit mutational signatures to all groups
# sigfit.fit.prelim = sigfit::fit_signatures(group.spectra, signatures.final,
#                                            iter=4000, warmup=2000, chains=2, seed=1756)
# cat("\nPlotting preliminary (suboptimal) results for refitting of all signatures to output directory...\n")
# invisible(sigfit::plot_all(sigfit.fit.prelim, exp_legend_pos="topleft",
#                            out_path=file.path("output", "Preliminary_Signature_Fitting")))


## (4) Re-fit extracted signatures to obtain refined signature exposures
# Based on a previous re-fitting of all 5 signatures to all phylogenetic groups
# (see above), we determined the sets of signatures with significant activity 
# (defined as lower bound >0.01 for the HPD interval of signature exposure)
# in each group:
#  - Signatures 1, 5, 7 are active in all groups
#  - Signature 2* is active in groups 57, 58, A3
#  - Signature A is active in groups A1, A2, A3

refine.exposures = function(sigs.idx, groups.idx) {
    cat("\nRefitting", paste(rownames(signatures.final)[sigs.idx], collapse=", "),
        "to groups:", paste(group.ids[groups.idx], collapse=", "), "\n\n")
    
    spectra = group.spectra[groups.idx, ]
    if (sum(groups.idx) == 1) {
        spectra = t(as.matrix(spectra))
    }
    sigfit.fit = sigfit::fit_signatures(spectra,
                                        signatures.final[sigs.idx, ],
                                        iter=4000, warmup=2000, seed=1756,
                                        control=list(adapt_delta=0.85))
    sigfit::retrieve_pars(sigfit.fit, "exposures")
}

# Re-fit signatures {1, 5, 7} to all groups except {57, 58, A1, A2, A3}
exposures.general = refine.exposures(1:3, !(group.ids %in% c("57", "58", "A1", "A2", "A3")))

# Re-fit signatures {1, 5, 7, 2*} to groups {57, 58}
exposures.57.58 = refine.exposures(1:4, group.ids %in% c("57", "58"))

# Re-fit signatures {1, 5, 7, A} to groups {A1, A2}
exposures.A1.A2 = refine.exposures(-4, group.ids %in% c("A1", "A2"))

# Re-fit signatures {1, 5, 7, 2*, A} to group A3
exposures.A3 = refine.exposures(1:5, group.ids == "A3")


## (5) Make definitive exposures table
# (NB. The information in this table will be output in Step 9)
exposures.final = as.data.frame(
    matrix(NA, nrow=nrow(group.spectra), ncol=nrow(signatures.final) * 3,
           dimnames=list(group.names,
                         sapply(c("(mean)", "(lower 95%)", "(upper 95%)"), function(x) {
                             paste(rownames(signatures.final), "exposure", x)
                         }))))

fetch.exposure = function(exposures, name) {
    sapply(exposures, function(e) {
        if (name %in% colnames(e)) {
            return(e[, name])
        }
        integer(nrow(e))
    })
}

for (name in rownames(signatures.final)) {
    idx = grep(name, colnames(exposures.final), fixed=T)
    exposures.final[, idx] = rbind(fetch.exposure(exposures.general, name),
                                   fetch.exposure(exposures.57.58, name),
                                   fetch.exposure(exposures.A1.A2, name),
                                   fetch.exposure(exposures.A3, name))
}


## (6) Plot signatures and exposures
cat("\nWriting definitive results of mutational signature analysis to output directory...\n")
cat("(Table of signature exposures will be written in Step 9)\n\n")
exposures.plot = list(mean=exposures.final[, grep("mean", colnames(exposures.final))],
                      lower_95=exposures.final[, grep("lower", colnames(exposures.final))],
                      upper_95=exposures.final[, grep("upper", colnames(exposures.final))])
for (i in 1:length(exposures.plot)) {
    colnames(exposures.plot[[i]]) = rownames(signatures.final)
}

invisible(sigfit::plot_all(counts=group.spectra, signatures=signatures.final, 
                           exposures=exposures.plot, out_path=OUTPUT$PLOTS.DIR, prefix="Definitive",
                           rec_legend_pos="topleft", exp_legend_pos="topleft", exp_margin_bottom=17.5))

# Output signatures table
write.table(cbind("Mutation type"=colnames(signatures.final), t(signatures.final)),
            file=OUTPUT$SIGNATURES, sep="\t", quote=F, row.names=F)


## (7) Plot pentanucleotide spectra of signatures 7 and A
# We construct transcriptional-strand-wise pentanucleotide spectra of
# C>T mutations in two groups of somatic variants:
#   (a) Tumour-unique (private) variants, which are highly enriched in sig. 7 mutations
#   (b) Pre-divergence ancestral variants, which are highly enriched in sig. A mutations
cat("Plotting pentanucleotide spectra...\n")

# Subfunction: reverse complement (strings)
rev.comp = function(nucleotide.list) {
    sapply(nucleotide.list, function(nucleotides) {
        paste(
            rev(sapply(strsplit(nucleotides, "")[[1]], function(nuc) {
                if (nuc == "A") "T"
                else if (nuc == "C") "G"
                else if (nuc == "G") "C"
                else if (nuc == "T") "A"
            })),
            collapse="")
    }, USE.NAMES=FALSE)
}

# Create indices that refer to entire snvs.metadata table
prediv.unique.idx = rep(FALSE, nrow(snvs.metadata))
prediv.unique.idx[tumour.only.idx][group.unique.idx[, "Basal trunk (ancestral) [A1]"]] = TRUE
stopifnot(identical(group.unique.idx[, "Basal trunk (ancestral) [A1]"],
                    prediv.unique.idx[tumour.only.idx]))

tumour.unique.large.idx = rep(FALSE, nrow(snvs.metadata))
tumour.unique.large.idx[tumour.only.idx][tumour.unique.any.idx] = TRUE
stopifnot(identical(tumour.unique.any.idx,
                    tumour.unique.large.idx[tumour.only.idx]))

# List pentanucleotide C>T mutation types
bases = c("A", "C", "G", "T")
penta.CtoT.types = paste0(rep(rep(bases, each=4), 16),
                          rep(bases, each=64),
                          "C",
                          rep(rep(bases, each=16), 4),
                          rep(bases, 64))

# Build spectra
counts = lapply(list("Predivergence ancestral (A1) variants"=prediv.unique.idx,
                     "Tumour-unique (private) variants"=tumour.unique.large.idx), function(present) {
    
    # Obtain Ref, Alt and context of the non-intergenic C>T variants in the group
    group.annot =
        annot.snvs.tonly[ annot.snvs.tonly$Meta_index %in% which(present) &
                              !grepl("stream", annot.snvs.tonly$Consequence) &
                              ((annot.snvs.tonly$Ref == "C" & annot.snvs.tonly$Allele == "T") |
                                   (annot.snvs.tonly$Ref == "G" & annot.snvs.tonly$Allele == "A")), ]
    group.annot$Context = substr(str_split_fixed(snvs.metadata$INFO[group.annot$Meta_index],
                                                 ";", 20)[,12],
                                 12, 16)
    stopifnot(all(group.annot$Ref %in% bases))
    stopifnot(all.equal(substr(group.annot$Context, 3, 3), group.annot$Ref))
    
    # Collapse contexts (and strands) to pyrimidine changes
    group.annot$Allele_pyr = as.character(group.annot$Allele)
    group.annot$Context_pyr = as.character(group.annot$Context)
    group.annot$Strand_pyr = as.integer(group.annot$Strand)
    
    idx = group.annot$Ref %in% c("A", "G")
    group.annot$Allele_pyr[idx] = rev.comp(group.annot$Allele_pyr[idx])
    group.annot$Context_pyr[idx] = rev.comp(group.annot$Context_pyr[idx])
    group.annot$Strand_pyr[idx] = -1 * group.annot$Strand_pyr[idx]
    
    # Count occurrences on each strand (strand=1 means unstranscribed)
    group.counts = sapply(penta.CtoT.types, function(type) {
        c(sum(grepl(type, group.annot$Context_pyr[group.annot$Strand_pyr == -1])),
          sum(grepl(type, group.annot$Context_pyr[group.annot$Strand_pyr == 1])))
    })
    rownames(group.counts) = c("Transcribed", "Untranscribed")
    stopifnot(sum(group.counts) == nrow(group.annot))
    group.counts / sum(group.counts)
})

# Plot
pdf(OUTPUT$PENTA.SPEC, width=45, height=9.525)
par(mar=c(5.5, 9.5, 6, 0))

colours = c("dodgerblue3", "red3")
xleft = 0
xright = 589
min.x = -2
max.x = 595
xright2 = 307.5
min.x2 = -1
max.x2 = 310.5
max.y = 0.04
min.y2 = -max.y
max.y2 = max.y
space = c(0, 0.3)
dot.shift = 0.01 * max.y

for (i in 1:length(counts)) {
    barplot(counts[[i]], beside=TRUE, space=space,
            col=colours, border=NA, ylim=c(0, max.y), yaxt="n", xlim=c(min.x, max.x),
            cex=1.3, cex.names=1.2, las=2, xaxs="i", family="mono")
    axis(side=2, cex.axis=2, las=2)
    legend("topleft", legend=rownames(counts[[i]]), 
           fill=colours, border=colours, xpd=TRUE, bty="n", cex=3, inset=c(0.005, 0.095))
    rect(xleft=xleft, xright=xright, ybottom=max.y*0.90, ytop=max.y,
         col="firebrick2", border="white", lty=par("lty"), lwd=par("lwd"))
    text(x=(xleft+xright)/2, y=max.y*0.95, labels="C>T", cex=3.75, font=2, col="white")
    title(names(counts)[i], cex.main=3)
}
invisible(dev.off())


cat("\nSaving generated objects to file ", OUTPUT$RDATA, "...\n", sep="")
save(group.spectra, signatures.final, exposures.final, file=OUTPUT$RDATA)

cat("\nDone\n\n")
